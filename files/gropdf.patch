*** gropdf.old	2023-04-11 19:34:32.617280066 +0000
--- gropdf	2023-04-11 19:34:32.657279374 +0000
***************
*** 23,28 ****
--- 23,41 ----
  use strict;
  use warnings;
  use Getopt::Long qw(:config bundling);
+ use Encode;
+ use File::Temp;
+ 
+ my $use_suppl_font = 1;
+ my $use_unicode_bookmark = 1;
+ my $D3_unicodefy = 1;
+ my $D3_afmtodit = 0;
+ my $D4_use_cache = 0;
+ my $D4_differences = 1;         # rebuild differences by a sparse array
+ my $D4_charset = 1;             # remove unused characters in charset string
+ my $O5_tounicode = 1;
+ $D3_afmtodit = 1 if $O5_tounicode;
+ my $D6_subset = 0;
  
  use constant
  {
***************
*** 31,36 ****
--- 44,50 ----
      PSNAME		=> 2,
      ASSIGNED		=> 3,
      USED                => 4,
+     SUPPL		=> 5,
  };
  
  my $prog=$0;
***************
*** 83,88 ****
--- 97,103 ----
  my $stream='';	# Current Text/Graphics stream
  my $cftsz=10;	# Current font sz
  my $cft;	# Current Font
+ my $cftsup=0;	# Current Font (supplemental)
  my $lwidth=1;	# current linewidth
  my $linecap=1;
  my $linejoin=1;
***************
*** 233,248 ****
--- 248,283 ----
  my $stats=0;
  my $unicodemap;
  my @idirs;
+ my %mopts,
+ 
+ my %AGL_to_unicode;
+ my @ucmap_tounicode;
  
  if (!GetOptions('F=s' => \$fd, 'I=s' => \@idirs, 'l' => \$frot,
  		'p=s' => \$fpsz, 'd!' => \$debug, 'help' => \$want_help,
  		'v' => \$version, 'version' => \$version,
  		'e' => \$embedall, 'y=s' => \$Foundry, 's' => \$stats,
+ 		'm=s' => \%mopts,
  		'u:s' => \$unicodemap))
  {
      &usage(1);
  }
  
+ sub checkyesno {
+     if (@_) {
+         local $_ = shift;
+         return $_ if /^\d+$/;
+         return 1  if /^[yt]/i;  # yes/no/true/false
+     }
+     return 0;
+ }
+ 
+ # modify internal options
+ $D3_afmtodit  = checkyesno($mopts{afmtodit})  if defined $mopts{afmtodit};
+ $O5_tounicode = checkyesno($mopts{tounicode}) if defined $mopts{tounicode};
+ $D6_subset    = checkyesno($mopts{subset})    if defined $mopts{subset};
+ #say STDERR "# \$afmtodit=$D3_afmtodit, \$tounicode=$O5_tounicode, \$subset=$D6_subset";
+ 
  unshift(@idirs,'.');
  
  &usage(0) if ($want_help);
***************
*** 272,277 ****
--- 307,314 ----
      }
  }
  
+ parse_cmap(\@ucmap_tounicode, $ucmap);
+ 
  # Search for 'font directory': paths in -f opt, shell var
  # GROFF_FONT_PATH, default paths
  
***************
*** 284,289 ****
--- 321,327 ----
  
  LoadDownload();
  LoadDesc();
+ Load_afmtodit() if $D3_afmtodit;
  
  my $unitwidth=$desc{unitwidth};
  
***************
*** 470,476 ****
  foreach my $fontno (sort keys %fontlst)
  {
      my $o=$fontlst{$fontno}->{FNT};
! 
      foreach my $ch (@{$o->{NO}})
      {
  	my $psname=$o->{NAM}->{$ch->[1]}->[PSNAME] || '/.notdef';
--- 508,514 ----
  foreach my $fontno (sort keys %fontlst)
  {
      my $o=$fontlst{$fontno}->{FNT};
!     if (!$use_suppl_font) {
      foreach my $ch (@{$o->{NO}})
      {
  	my $psname=$o->{NAM}->{$ch->[1]}->[PSNAME] || '/.notdef';
***************
*** 489,494 ****
--- 527,601 ----
  	splice(@{$o->{DIFF}},257);
  	splice(@{$o->{WIDTH}},257);
      }
+     } else {
+     rebuild_font($o);
+ 
+     if ($use_suppl_font) {
+ 	my $g = $o;
+ 	while ($g = $g->{NEXT}) {
+ 	    rebuild_font($g);
+ 	}
+     }
+ 
+     if ($D4_charset >= 0) {
+ 	my @list = values %{$o->{NAM}};
+         @list = grep $_->[USED], @list if $D4_charset;
+ 	my $p = GetObj($fontlst{$fontno}->{OBJ});
+ 	my $q = GetObj($p->{FontDescriptor});
+ 	$q->{CharSet} = bless do {
+             my %seen; [ grep defined && !$seen{$_}++, map $_->[PSNAME], @list ]
+         }, 'STRING';
+     }
+     }
+ 
+     if ($D6_subset) {
+         if (my $subset = $fontlst{$fontno}->{subset}) {
+ 
+             my @glyphs;
+             # my $o=$fontlst{$fontno}->{FNT};
+             push @glyphs, get_glyphs($o);
+             if ($use_suppl_font) {
+                 my $g = $o;
+                 while ($g = $g->{NEXT}) {
+                     push @glyphs, get_glyphs($g);
+                 }
+             }
+ 
+             my $fontkey = $subset->{fontkey};
+             my $filename = $download{$fontkey};
+             my ($suffix) = $filename =~ /(\.\w+)$/;
+             my $tmp = File::Temp->new(SUFFIX => $suffix);
+             my @command = (
+                 "pyftsubset", $filename,
+                 "--glyphs=".join(",", @glyphs),
+                 "--output-file=".$tmp->filename,
+                 "--no-subset-tables+=FFTM", # xxxxx
+             );
+ 
+             my ($l1,$l2,$l3,$t1stream);
+             #Warn("@command");
+             system @command;
+             if ($? == 0) {
+                 ($l1,$l2,$l3,$t1stream) = GetType1($tmp->filename);
+             } else {
+                 Warn("@command: $!");
+                 ($l1,$l2,$l3,$t1stream) = GetType1($filename);
+             }
+             unlink $tmp->filename;
+             Warn("incorrect font format for '$fontkey' ($l1)")
+                 if !defined($t1stream);
+ 
+             my ($ono) = split " ", $fontlst{$fontno}->{OBJ};
+             $obj[$ono + 3] = {  # FontFile
+                 DATA => {
+                     Length1 => $l1 // 0,
+                     Length2 => $l2 // 0,
+                     Length3 => $l3 // 0,
+                 },
+                 STREAM => $t1stream,
+             };
+         }
+     }
  }
  
  foreach my $o (3..$objct)
***************
*** 498,504 ****
  
  #my $encrypt=BuildObj(++$objct,{'Filter' => '/Standard', 'V' => 1, 'R' => 2, 'P' => 252});
  #PutObj($objct);
! PutObj(2);
  
  my $xrefct=$fct;
  
--- 605,611 ----
  
  #my $encrypt=BuildObj(++$objct,{'Filter' => '/Standard', 'V' => 1, 'R' => 2, 'P' => 252});
  #PutObj($objct);
! PutObj($cat->{Pages});          # PutObj(2);
  
  my $xrefct=$fct;
  
***************
*** 836,844 ****
  				),
  		'Type' =>  '/Catalog'});
  
- 	    $cat=$obj[$objct]->{DATA};
  	    $objct++;
! 	    $pages=$obj[2]->{DATA};
  	    Put("%PDF-1.4\n\x25\xe2\xe3\xcf\xd3\n");
  	}
      }
--- 943,951 ----
  				),
  		'Type' =>  '/Catalog'});
  
  	    $objct++;
! 	    $cat = GetObj(1);
! 	    $pages = GetObj($cat->{Pages}); # GetObj(2)
  	    Put("%PDF-1.4\n\x25\xe2\xe3\xcf\xd3\n");
  	}
      }
***************
*** 1023,1028 ****
--- 1130,1148 ----
  		    $t=~s/\\e/\\\\/g;
  		    $t=~m/(^.*\/Title \()(.*)(\).*)/;
  		    my ($pre,$title,$post)=($1,$2,$3);
+ 		    if ($use_unicode_bookmark) {
+ 			if ($D3_unicodefy) {
+ 			    $title = unicodefy($title);
+ 			} else {
+ 			    $title =~ s/\\\[u([0-9A-F_]+)\]/join(
+ 				'', map { pack "U", hex } split '_', $1)/eg;
+ 			    $title =~ s/\\e/\\/g;
+ 			}
+ 			if ($title =~ /[^[:ascii:]]/) {
+ 			    $title = join '', map sprintf("\\%o", $_),
+ 			    unpack "C*", encode("utf16", $title);
+ 			}
+ 		    }
  		    $title=~s/(?<!\\)\(/\\\(/g;
  		    $title=~s/(?<!\\)\)/\\\)/g;
  		    my @xwds=split(' ',"<< $pre$title$post >>");
***************
*** 1484,1489 ****
--- 1604,1614 ----
      $l=~s/Action/A/;
      $l=~s'/Subtype /URI'/S /URI';
      $l=~s(\\\[u00(..)\])(chr(hex($1)))eg;
+     $l=~s(\\\[u([0-9A-F]+)\])(
+         join '', map sprintf("%%%02x", $_), map unpack("C*", $_), split //,
+         encode("utf8", pack("U", hex($1)))
+     )eg;
+ 
      my @xwds=split(' ',"<< $l >>");
      my $annotno=BuildObj(++$objct,ParsePDFValue(\@xwds));
      my $annot=$obj[$objct];
***************
*** 2357,2362 ****
--- 2482,2488 ----
  sub PutObj
  {
      my $ono=shift;
+     ($ono)=split(' ',$ono);
      my $msg="$ono 0 obj ";
      $obj[$ono]->{XREF}=$fct;
      if (exists($obj[$ono]->{STREAM}))
***************
*** 2417,2422 ****
--- 2543,2552 ----
      {
  	$$pmsg.="$$fld 0 R$term";
      }
+     elsif ($typ eq 'STRING')
+     {
+ 	$$pmsg.="(@$fld)$term";
+     }
  }
  
  sub BuildObj
***************
*** 2462,2467 ****
--- 2592,2606 ----
      my $ascent=0;
      my $charset='';
  
+     $fnt{NM} = 'F'.$fontno;
+     $fnt{SUPPL} = 0;
+     my @remap = (127..138, 144..255);
+     @remap = grep !$ucmap_tounicode[$_], @remap;
+     $fnt{REMAP} = \@remap;
+     my @used;
+     $used[$_] = 1 for 0..255;
+     $used[$_] = 0 for @remap;
+ 
      while (<$f>)
      {
  	chomp;
***************
*** 2504,2509 ****
--- 2643,2650 ----
  #           next if $r[3] >255;
              $r[4]=$r[0] if !defined($r[4]);
              $fnt{NAM}->{$r[0]}=[$p[0],$r[3],'/'.$r[4],$r[3],0];
+             $fnt{NAM}->{$r[0]}->[SUPPL] = 0;
+             $fnt{NAM}->{$r[0]}->[USED] = $used[$r[3]] || 0;
              $fnt{NO}->[$r[3]]=[$r[0],$r[0]];
              $lastnm=$r[0];
              $lastchr=$r[3] if $r[3] > $lastchr;
***************
*** 2528,2538 ****
  
      my $fno=0;
      my $slant=0;
!     $fnt{DIFF}=[];
!     $fnt{WIDTH}=[];
      $fnt{NAM}->{''}=[0,-1,'/.notdef',-1,0];
      $slant=-$fnt{'slant'} if exists($fnt{'slant'});
!     $fnt{'spacewidth'}=700 if !exists($fnt{'spacewidth'});
  
      $t1flags|=2**0 if $fixwid > -1;
      $t1flags|=(exists($fnt{'special'}))?2**2:2**5;
--- 2669,2681 ----
  
      my $fno=0;
      my $slant=0;
!     #$fnt{DIFF}=[];
!     #$fnt{WIDTH}=[];
      $fnt{NAM}->{''}=[0,-1,'/.notdef',-1,0];
+     $fnt{NAM}->{''}->[SUPPL] = 0;
      $slant=-$fnt{'slant'} if exists($fnt{'slant'});
!     #$fnt{'spacewidth'}=700 if !exists($fnt{'spacewidth'});
!     $fnt{'spacewidth'} = 0 if !exists($fnt{'spacewidth'}); # xxxxx
  
      $t1flags|=2**0 if $fixwid > -1;
      $t1flags|=(exists($fnt{'special'}))?2**2:2**5;
***************
*** 2542,2561 ****
      if (exists($download{$fontkey}))
      {
          # Not a Base Font
!         my ($l1,$l2,$l3,$t1stream)=GetType1($download{$fontkey});
!         Warn("incorrect font format for '$fontkey' ($l1)")
!             if !defined($t1stream);
          $fno=++$objct;
          $fontlst{$fontno}->{OBJ}=BuildObj($objct,
                          {'Type' => '/Font',
  			'Subtype' => '/Type1',
  			'BaseFont' => '/'.$fnt{internalname},
! 			'Widths' => $fnt{WIDTH},
  			'FirstChar' => 0,
  			'LastChar' => $lastchr,
  			'Encoding' => BuildObj($objct+1,
  				    {'Type' => '/Encoding',
! 				    'Differences' => $fnt{DIFF}
  				    }
  				    ),
  			'FontDescriptor' => BuildObj($objct+2,
--- 2685,2715 ----
      if (exists($download{$fontkey}))
      {
          # Not a Base Font
!         my ($l1,$l2,$l3,$t1stream);
!         if ($D6_subset) {
!             if ($download{$fontkey} =~ /\.[ot]tf$/i) {
!                 $fontlst{$fontno}->{subset} = { fontkey => $fontkey };
!             }
!         }
!         if (!$fontlst{$fontno}->{subset}) {
!             ($l1,$l2,$l3,$t1stream)=GetType1($download{$fontkey});
!             Warn("incorrect font format for '$fontkey' ($l1)")
!                 if !defined($t1stream);
!         }
! 
          $fno=++$objct;
          $fontlst{$fontno}->{OBJ}=BuildObj($objct,
                          {'Type' => '/Font',
  			'Subtype' => '/Type1',
  			'BaseFont' => '/'.$fnt{internalname},
! 			#'Widths' => $fnt{WIDTH},
! 			'Widths' => [],
  			'FirstChar' => 0,
  			'LastChar' => $lastchr,
  			'Encoding' => BuildObj($objct+1,
  				    {'Type' => '/Encoding',
! 				    #'Differences' => $fnt{DIFF}
! 				    'Differences' => [],
  				    }
  				    ),
  			'FontDescriptor' => BuildObj($objct+2,
***************
*** 2605,2616 ****
                          {'Type' => '/Font',
  			'Subtype' => '/Type1',
  			'BaseFont' => '/'.$fnt{internalname},
! 			'Widths' => $fnt{WIDTH},
  			'FirstChar' => 0,
  			'LastChar' => $lastchr,
  			'Encoding' => BuildObj($objct+1,
  				    {'Type' => '/Encoding',
! 				    'Differences' => $fnt{DIFF}
  				    }
  				    ),
  			'FontDescriptor' => BuildObj($objct+2,
--- 2759,2772 ----
                          {'Type' => '/Font',
  			'Subtype' => '/Type1',
  			'BaseFont' => '/'.$fnt{internalname},
! 			#'Widths' => $fnt{WIDTH},
! 			'Widths' => [],
  			'FirstChar' => 0,
  			'LastChar' => $lastchr,
  			'Encoding' => BuildObj($objct+1,
  				    {'Type' => '/Encoding',
! 				    #'Differences' => $fnt{DIFF}
! 				    'Differences' => [],
  				    }
  				    ),
  			'FontDescriptor' => BuildObj($objct+2,
***************
*** 2663,2668 ****
--- 2819,2825 ----
      Die("unable to open font '$file' for embedding") if !defined($f);
  
      $head=GetChunk($f,1,"currentfile eexec");
+     $body=$tail='';
      $body=GetChunk($f,2,"00000000") if !eof($f);
      $tail=GetChunk($f,3,"cleartomark") if !eof($f);
  
***************
*** 2856,2862 ****
      my $thispg=BuildObj($objct,
  		    {'Type' => '/Page',
  		    'Group' => {'CS' => '/DeviceRGB', 'S' => '/Transparency'},
! 		    'Parent' => '2 0 R',
  		    'Contents' => [ BuildObj($objct+1,
  				{'Length' => 0}
  				) ],
--- 3013,3019 ----
      my $thispg=BuildObj($objct,
  		    {'Type' => '/Page',
  		    'Group' => {'CS' => '/DeviceRGB', 'S' => '/Transparency'},
! 		    'Parent' => $cat->{Pages}, # '2 0 R',
  		    'Contents' => [ BuildObj($objct+1,
  				{'Length' => 0}
  				) ],
***************
*** 2914,2921 ****
--- 3071,3080 ----
  
  #	IsText();
      $cft="$par";
+     $cftsup=0;
      $fontchg=1;
  #	$stream.="/F$cft $cftsz Tf\n" if $cftsz;
+     if ($D4_use_cache) {
      $widtbl=CacheWid($par);
      $origwidtbl=[];
  
***************
*** 2925,2930 ****
--- 3084,3090 ----
      }
  
  #     $krntbl=$fnt->{KERN};
+     }
  }
  
  sub CacheWid
***************
*** 2943,2955 ****
--- 3103,3119 ----
  {
      my $fnt=shift;
      my @cwid;
+     if ($D4_use_cache) {
      $origwidtbl=[];
+     }
  
      foreach my $w (@{$fnt->{NO}})
      {
  	my $wid=(defined($w) and defined($w->[1]))?$fnt->{NAM}->{$w->[1]}->[WIDTH]:0;
  	push(@cwid,$wid*$cftsz);
+ 	if ($D4_use_cache) {
  	push(@{$origwidtbl},$wid);
+ 	}
      }
  
      return(\@cwid);
***************
*** 2970,2976 ****
--- 3134,3144 ----
  	if (defined($cft))
  	{
  	    $whtsz=$fontlst{$cft}->{FNT}->{spacewidth}*$cftsz;
+ 	    if (!$cftsup) {
  	    $stream.="/F$cft $cftsz Tf\n";
+ 	    } else {
+ 	    $stream.="/F$cft.$cftsup $cftsz Tf\n";
+ 	    }
  	}
  	$stream.="$curkern Tc\n";
      }
***************
*** 2988,2994 ****
--- 3156,3166 ----
      {
  	PutLine(0);
  	$whtsz=$fontlst{$cft}->{FNT}->{spacewidth}*$cftsz;
+ 	if (!$cftsup) {
  	$stream.="/F$cft $cftsz Tf\n" if $cftsz and defined($cft);
+ 	} else {
+ 	$stream.="/F$cft.$cftsup $cftsz Tf\n" if $cftsz and defined($cft);
+ 	}
  	$fontchg=0;
      }
  
***************
*** 3022,3028 ****
--- 3194,3202 ----
  	Set_LWidth() if $lwidth < 1;
  #		$stream.="/F$cft $cftsz Tf\n";
  	$fontchg=1;
+ 	if ($D4_use_cache) {
  	$widtbl=CacheWid($cft);
+ 	}
      }
      else
      {
***************
*** 3626,3631 ****
--- 3800,3806 ----
  sub TextWid
  {
      my $txt=shift;
+     my $sup=shift;
      my $fnt=shift;
      my $w=0;
      my $ck=0;
***************
*** 3633,3640 ****
--- 3808,3820 ----
      foreach my $c (split('',$txt))
      {
  	my $cn=ord($c);
+ 	$cn+=$sup*256;
+ 	if (!$D4_use_cache) {
+ 	$w += $fnt->{NAM}->{$fnt->{NO}->[$cn]->[1]}->[WIDTH]*$cftsz;
+ 	} else {
  	$widtbl->[$cn]=$origwidtbl->[$cn]*$cftsz if !defined($widtbl->[$cn]);
  	$w+=$widtbl->[$cn];
+ 	}
      }
  
      $ck=length($txt)*$curkern;
***************
*** 3646,3651 ****
--- 3826,3834 ----
  {
      my $par=shift;
      my $fnt=$fontlst{$cft}->{FNT};
+     my $sup = shift || 0;
+     $fontchg=1 if $cftsup != $sup;
+     $cftsup = $sup;
  
      if ($kernadjust != $curkern)
      {
***************
*** 3660,3677 ****
      foreach my $j (0..length($par2)-1)
      {
  	my $cn=ord(substr($par2,$j,1));
! 	my $chnm=$fnt->{NAM}->{$fnt->{NO}->[$cn]->[1]};
  
! 	if ($chnm->[USED]==0)
  	{
! 	    $chnm->[USED]=1;
! 	}
! 	elsif ($fnt->{NO}->[$cn]->[0] ne $fnt->{NO}->[$cn]->[1])
! 	{
! 	    # A glyph has already been remapped to this char, so find a spare
! 
! 	    my $cn2=RemapChr($cn,$fnt,$fnt->{NO}->[$cn]->[0]);
! 	    $stream.="% MMM Remap $cn to $cn2\n" if $debug;
  
  	    if ($cn2)
  	    {
--- 3843,3856 ----
      foreach my $j (0..length($par2)-1)
      {
  	my $cn=ord(substr($par2,$j,1));
! 	$cn+=$sup*256;
! 	my $chnm=$fnt->{NO}->[$cn]->[1];
  
! 	if (!$fnt->{NAM}->{$chnm}->[USED])
  	{
! 	    my ($cn2, $sup2) = RemapChr($cn, $fnt, $chnm);
! 	    $stream.="% MMM Remap $cn,$sup to $cn2,$sup2\n" if $debug;
! 	    Msg(0, "got: $fnt->{NM}.$sup2; expected: $fnt->{NM}.$sup\n") if $sup != $sup2;
  
  	    if ($cn2)
  	    {
***************
*** 3688,3694 ****
  	    }
  	}
      }
!     my $wid=TextWid($par2,$fnt);
  
      $par=reverse(split('',$par)) if $xrev and $par!~m/^!\|!\|(\d\d\d)/;
  
--- 3867,3873 ----
  	    }
  	}
      }
!     my $wid=TextWid($par2,$sup,$fnt);
  
      $par=reverse(split('',$par)) if $xrev and $par!~m/^!\|!\|(\d\d\d)/;
  
***************
*** 3714,3720 ****
--- 3893,3903 ----
      {
  	PutLine();
  	$whtsz=$fontlst{$cft}->{FNT}->{spacewidth}*$cftsz;
+ 	if (!$cftsup) {
  	$stream.="/F$cft $cftsz Tf\n", $fontchg=0 if $fontchg && defined($cft);
+ 	} else {
+ 	$stream.="/F$cft.$cftsup $cftsz Tf\n", $fontchg=0 if $fontchg && defined($cft);
+ 	}
      }
  
      $gotT=1;
***************
*** 3815,3823 ****
  {
      my $par=shift;
  
!     my ($par2,$nm)=FindChar($par);
! 
!     do_t($par2);
      $nomove=$fontlst{$cft}->{FNT}->{NAM}->{$par}->[WIDTH]*$cftsz ;
  }
  
--- 3998,4004 ----
  {
      my $par=shift;
  
!     do_t(FindChar($par));
      $nomove=$fontlst{$cft}->{FNT}->{NAM}->{$par}->[WIDTH]*$cftsz ;
  }
  
***************
*** 3828,3838 ****
  
      if (exists($fnt->{NAM}->{$chnm}))
      {
! 	my $ch=$fnt->{NAM}->{$chnm}->[ASSIGNED];
! 	$ch=RemapChr($ch,$fnt,$chnm) if ($ch > 255);
! 	$fnt->{NAM}->{$chnm}->[USED]=0 if $fnt->{NO}->[$ch]->[1] eq $chnm;
! 
! 	return(($ch<32)?sprintf("!|!|%03o",$ch):chr($ch),$widtbl->[$ch]);
      }
      else
      {
--- 4009,4017 ----
  
      if (exists($fnt->{NAM}->{$chnm}))
      {
! 	my ($ch,$sup,$used)=@{$fnt->{NAM}->{$chnm}}[ASSIGNED,SUPPL,USED];
! 	($ch,$sup) = RemapChr($ch,$fnt,$chnm) if !$used;
! 	return ($ch<32)? sprintf("!|!|%03o",$ch) : chr($ch), $sup;
      }
      else
      {
***************
*** 3845,3886 ****
      my $ch=shift;
      my $fnt=shift;
      my $chnm=shift;
!     my $unused=0;
  
!     foreach my $un (0..$#{$fnt->{NO}})
!     {
! 	next if $un >= 139 and $un <= 144;
! 	$unused=$un,last if $fnt->{NO}->[$un]->[1] eq '';
      }
  
!     if (!$unused)
!     {
! 	foreach my $un (128..255)
! 	{
! 	    next if $un >= 139 and $un <= 144;
! 	    my $glyph=$fnt->{NO}->[$un]->[1];
! 	    $unused=$un,last if $fnt->{NAM}->{$glyph}->[USED] == 0;
  	}
      }
  
!     if ($unused && $unused <= 255)
      {
          my $glyph=$fnt->{NO}->[$unused]->[1];
          delete($fontlst{$cft}->{CACHE}->{$cftsz});
          $fnt->{NAM}->{$chnm}->[ASSIGNED]=$unused;
          $fnt->{NAM}->{$chnm}->[USED]=1;
          $fnt->{NO}->[$unused]->[1]=$chnm;
          $widtbl=CacheWid($cft);
  
  	$stream.="% AAA Assign $chnm ($ch) to $unused\n" if $debug;
  
  	$ch=$unused;
! 	return($ch);
      }
      else
      {
          Warn("too many glyphs used in font '$cft'");
!         return(32);
      }
  }
  
--- 4024,4112 ----
      my $ch=shift;
      my $fnt=shift;
      my $chnm=shift;
!     my $unused;
  
!     if (!$fnt->{SUPPL} && !$fnt->{NAM}->{$chnm}->[USED]) {
! 	my ($l, $r) = (0, $#{$fnt->{REMAP}});
! 	while ($l <= $r) {
! 	    if ($fnt->{REMAP}->[my $m = int(($l + $r) / 2)] == $ch) {
! 		splice @{$fnt->{REMAP}}, $m, 1;
! 		#$stream .= "% AAA Assign $chnm ($ch) to $ch\n" if $debug;
! 		$fnt->{NAM}->{$chnm}->[USED] = 1;
! 		return ($ch, $fnt->{SUPPL});
! 	    } elsif ($fnt->{REMAP}->[$m] > $ch) {
! 		$r = $m - 1;
! 	    } else {
! 		$l = $m + 1;
! 	    }
! 	}
      }
  
!     while (defined(my $un = shift @{$fnt->{REMAP}})) {
! 	my $ux = $un + $fnt->{SUPPL} * 256;
! 	my $glyph = $fnt->{NO}->[$ux]->[1];
! 	$unused = $un, last if !$glyph || !$fnt->{NAM}->{$glyph}->[USED];
!     }
! 
!     if ($use_suppl_font) {
! 	if (!defined $unused) {
! 	    if (!$fnt->{NEXT}) {
! 		my @reserved = (32); # space
! 		my %reserved = map +($_ => 1), @reserved;
! 		my $fnt2 = {
! 		    (map +($_ => $fnt->{$_}), qw/NM NO NAM/),
! 		    SUPPL => $fnt->{SUPPL} + 1,
! 		    REMAP => [ grep !$reserved{$_}, 0..255 ],
! 		};
! 		for (@reserved) {
! 		    $fnt2->{NO}->[$_ + $fnt2->{SUPPL} * 256] =
! 			$fnt->{NO}->[$_ + $fnt->{SUPPL} * 256];
! 		}
! 		$fnt->{NEXT} = $fnt2;
! 	    }
! 	    return RemapChr($ch, $fnt->{NEXT}, $chnm);
! 	}
! 
! 	my $ux = $unused + $fnt->{SUPPL} * 256;
! 	my $glyph = $fnt->{NO}->[$ux]->[1];
! 	if ($D4_use_cache) {
! 	delete($fontlst{$cft}->{CACHE}->{$cftsz});
! 	}
! 	@{$fnt->{NAM}->{$chnm}}[ASSIGNED, SUPPL, USED] = ($unused, $fnt->{SUPPL}, 1);
! 	$fnt->{NO}->[$ux]->[1] = $chnm;
! 	if ($D4_use_cache) {
! 	$widtbl = CacheWid($cft);
  	}
+ 
+ 	$stream .= "% AAA Assign $chnm ($ch) to ".sprintf("\\%o (%d)", $unused, $unused).
+ 	    ($fnt->{SUPPL}? ".$fnt->{SUPPL}" : '')."\n" if $debug;
+ 
+ 	$ch = $unused;
+ 	return ($ch, $fnt->{SUPPL});
      }
  
!     if (defined $unused && $unused <= 255)
      {
          my $glyph=$fnt->{NO}->[$unused]->[1];
+ 	if ($D4_use_cache) {
          delete($fontlst{$cft}->{CACHE}->{$cftsz});
+ 	}
          $fnt->{NAM}->{$chnm}->[ASSIGNED]=$unused;
          $fnt->{NAM}->{$chnm}->[USED]=1;
          $fnt->{NO}->[$unused]->[1]=$chnm;
+ 	if ($D4_use_cache) {
          $widtbl=CacheWid($cft);
+ 	}
  
  	$stream.="% AAA Assign $chnm ($ch) to $unused\n" if $debug;
  
  	$ch=$unused;
! 	return($ch,0);
      }
      else
      {
          Warn("too many glyphs used in font '$cft'");
!         return(32,0);
      }
  }
  
***************
*** 3919,3924 ****
--- 4145,4403 ----
      PutHotSpot($xpos) if defined($mark);
  }
  
+ 
+ =begin comment
+ 
+ There are some subs to work around "too many glyphs used in font 'xx'.
+ 
+ rebuild_font:
+ 
+ adds /Encoding to the font when more than 256 glyphs are used in the
+ font. ($use_suppl_font)
+ 
+ removes unused characters from /Differences array and /Charset string to
+ reduce pdf size. ($D4_differences $D4_charset)
+ 
+ =end comment
+ 
+ =cut
+ 
+ sub rebuild_font {
+     my $fnt = shift;            # $fontlst{$fontno}->{FNT}
+     my $obj = $pages->{Resources}->{Font}->{$fnt->{NM}};
+ 
+     if ($fnt->{SUPPL}) {
+         my $p = GetObj($obj);
+         $obj = BuildObj($objct + 1, {
+             (map +($_ => $p->{$_}), qw/Type Subtype BaseFont FontDescriptor/),
+             Encoding => BuildObj($objct + 2, {
+                 Type => '/Encoding',
+             }),
+         });
+         $objct += 2;
+         $pages->{Resources}->{Font}->{"$fnt->{NM}.$fnt->{SUPPL}"} = $obj;
+     }
+ 
+     my @tounicode = ();
+     if ($O5_tounicode) {
+         if (!$fnt->{SUPPL}) {
+             @tounicode = @ucmap_tounicode;
+         }
+     }
+ 
+     my (@diff, @width);
+     foreach my $cn (0..255) {
+         my $ch = $fnt->{NO}->[$cn + $fnt->{SUPPL} * 256];
+         if ($ch && defined $ch->[1] && $fnt->{NAM}->{$ch->[1]}->[USED]) {
+             push @diff, $fnt->{NAM}->{$ch->[1]}->[PSNAME] || '/.notdef';
+             push @width, $fnt->{NAM}->{$ch->[1]}->[WIDTH] || 0;
+             if ($O5_tounicode) {
+                 if (!$tounicode[$cn]) {
+                     my $psname = substr $fnt->{NAM}->{$ch->[1]}->[PSNAME], 1;
+                     my $hex = $AGL_to_unicode{$psname};
+                     unless (defined $hex) {
+                         $hex = $1 if $psname =~ /^u(?:ni)?([\dA-F_]+)/;
+                     }
+                     if ($hex && $cn ne hex($hex)) {
+                         $hex =~ s/_/ /g;
+                         $tounicode[$cn] = "<$hex>";
+                     }
+                 }
+             }
+         } else {
+             push @diff, '/.notdef';
+             push @width, 0;
+         }
+     }
+     unshift @diff, 0;
+ 
+     my $p = GetObj($obj);
+     $p->{FirstChar} = 0;
+     $p->{LastChar} = 255;
+     $p->{Widths} = \@width;
+     my $q = GetObj($p->{Encoding});
+     $q->{Differences} = \@diff;
+ 
+     if ($D4_differences) {
+         my @new_diff = ();
+         my @name = ();
+         my $code = 0;
+         my $end;
+         while (1) {
+             local $_ = shift @{$q->{Differences}};
+             if (!defined || /^\/.notdef$/ || !/^\//) {
+                 $end = $code + @name if @name;
+                 push @new_diff, $code, @name if @name;
+                 last if !defined;
+                 $code = !/^\//? $_ : $code + @name + 1;
+                 @name = ();
+             } else {
+                 push @name, $_;
+             }
+         }
+ 
+         my $start = $new_diff[0];
+         splice(@{$p->{Widths}}, $end) if $end < $#{$p->{Widths}};
+         splice(@{$p->{Widths}}, 0, $start) if $start > 0;
+         $p->{LastChar} = $start + $#{$p->{Widths}};
+         $p->{FirstChar} = $start;
+ 
+         @{$q->{Differences}} = @new_diff;
+     }
+ 
+     if ($O5_tounicode) {
+         my @bfchar;
+         for (0 .. 255) {
+             if (my $hex = $tounicode[$_]) {
+                 push @bfchar, sprintf("<%04X> %s", $_, $hex);
+             }
+         }
+         if (@bfchar) {
+             my $cmap = $ucmap;
+             $cmap =~ s/^\s*%.*//gm;
+             $cmap =~ s/\d+\s+beginbf(range|char)\s+(.*?)\s+endbf\1\s*//sg;
+             $cmap =~ s/\bendcmap\b/join "\n",
+                 sprintf("%d beginbfchar", scalar @bfchar), @bfchar, "endbfchar",
+                 $&/e;
+             $p->{ToUnicode} = BuildObj($objct + 1, {});
+             $obj[$objct + 1]->{STREAM} = $cmap;
+             $objct++;
+         }
+     }
+ 
+ }
+ 
+ =begin comment
+ 
+ unicodefy, decode_groff_char_to_unicode, Load_afmtodit:
+ 
+ converts groff characters in bookmarks to unicode and removes some of
+ the groff escape sequences. ($use_unicode_bookmark $D3_unicodefy)
+ 
+ Conversion from groff characters to unicode is obvious for \[uXXXX],
+ otherwise using %AGL_to_unicode in afmtodit. ($D3_afmtodit)
+ 
+ By default $D3_afmtodit is 0, because many groff characters can be
+ converted to unicode without using AGL_to_unicode.
+ 
+ =end comment
+ 
+ =cut
+ 
+ sub unicodefy {
+     local $_ = shift;
+     my $output = '';
+     while (length > 0) {
+ 	if (s/^\\\[(.*?)\]// || s/^\\\((..)//) {
+ 	    my ($ch, $fallback) = ($1, $&);
+ 	    $output .= decode_groff_char_to_unicode($ch) // $fallback;
+         } elsif (s/^\\f\[(.*?)\]// || s/^\\f\((..)// || s/^\\f.// ||
+                  s/^\\s-?\d+// || s/^\\[&]//) {
+             # ignore \f, \s, \&
+ 	} elsif (s/^\\[e\\]//) {
+ 	    $output .= '\\';
+ 	} elsif (s/^\\[ ~]// ||
+ 		 s/^\\h('[^']*'|\[.*?\])//) {
+ 	    $output .= ' ';
+ 	} elsif (s/^\\[%0|^\/,:]//) {
+ 	    ;
+ 	} elsif (s/^\\[a-zA-Z]('[^']*?'|\[.*?\])//) {
+ 	    $output .= $&;
+ 	} elsif (s/^\\(.)//) {
+ 	    $output .= $1;
+ 	} else {
+ 	    s/.//;
+ 	    $output .= $&;
+ 	}
+     }
+     $output;
+ }
+ 
+ sub decode_groff_char_to_unicode {
+     my ($name) = @_;
+     if ($name =~ /^u([0-9A-F_]+)$/) {
+ 	return join '', map { pack "U", hex } split '_', $1;
+     }
+     if (my $fnt = $fontlst{$cft}->{FNT}) {
+ 	if (my $ch = $fnt->{NAM}->{$name}) {
+ 	    my $psname = substr $ch->[PSNAME], 1;
+ 	    if (my $u = $AGL_to_unicode{$psname}) {
+ 		return pack "U", hex $u;
+ 	    }
+ 	}
+     }
+     undef;
+ }
+ 
+ sub Load_afmtodit
+ {
+     my @afmtodit = grep -x, map catfile($_, 'afmtodit'), grep /./ && -d,
+         map split($cfg{RT_SEP}, $_), grep defined, $ENV{GROFF_BIN_DIR}, $ENV{PATH};
+     if (@afmtodit) {
+ 	open my $f, "<", $afmtodit[0];
+ 	my $afmtodit = join '', <$f>;
+ 	if ($afmtodit =~ /%AGL_to_unicode\s*=\s*(\(.*?\))\s*;/s) {
+ 	    %AGL_to_unicode = eval $1;
+ 	}
+     }
+     Warn("Could not find afmtodit") if !%AGL_to_unicode;
+ }
+ 
+ sub catfile {
+     if (eval { require File::Spec; 1; }) {
+         File::Spec->catfile(@_);
+     } else {
+         join '/', @_;
+     }
+ }
+ 
+ =begin comment
+ 
+ parse_cmap:
+ 
+ gets glyph number and unicode equivalents defined in it from a cmapfile
+ specified by the gropdf options or from the default ucmap.
+ 
+ =end comment
+ 
+ =cut
+ 
+ sub parse_cmap {
+     my ($tounicode, $cmap) = @_;
+     $cmap =~ s/^\s*%.*//gm;
+     my $hex = qr/[\da-f]+/i;
+     while ($cmap =~ s/\d+\s+beginbf(range|char)\s*(.*?)\s*endbf\1\s*//s) {
+         my ($t, $bf) = ($1, $2);
+         while ($bf =~ s/^\s*<\s*($hex)\s*>\s*//s) {
+             my ($start, $end) = (hex $1, undef);
+             $end = hex $1 if $t eq 'range' && $bf =~ s/^\s*<\s*($hex)\s*>\s*//s;
+             $end //= $start;
+             my $value = '';
+             $value = $1 || $2 if $bf =~ s/^(?:\[\s*([^\]]+)\]|(\<[^\>]+\>|\S+))\s*//s;
+             $value =~ s/<((?:$hex|\s)+)>/my $h = $1; $h =~ s{\s}{}g; "<$h>"/eg;
+             my @value = split /\s+/, $value;
+             for ($start .. $end) {
+                 last unless @value;
+                 $tounicode->[$_] = shift @value;
+             }
+         }
+     }
+ }
+ 
+ 
+ sub get_glyphs {
+     my $fnt = shift;            # $fontlst{$fontno}->{FNT}
+ 
+     my @glyphs = ();
+     foreach my $i (0..255) {
+         my $ch = $fnt->{NO}->[$i + $fnt->{SUPPL} * 256];
+         if ($ch && defined $ch->[1] && $fnt->{NAM}->{$ch->[1]}->[USED]) {
+             push @glyphs, substr $fnt->{NAM}->{$ch->[1]}->[PSNAME], 1;
+         }
+     }
+     return @glyphs;
+ }
+ 
  1;
  
  # Local Variables:
